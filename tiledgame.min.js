/**
 * @author Mirielle S.
 * title: tiledgame.js
 * Last Revision: 1st Nov. 2020
 * 
 * 
 * MIT License 
 * Copyright (c) 2020 CodeBreaker
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
class Vec2d{static createFrom(t){if(t instanceof Vec2d)return t;if(t instanceof Array){let e=void 0===t[2]?1:t[2];return new Vec2d(t[0],t[1],e)}if(t instanceof Object){let e=void 0===t.w?1:t.w;return new Vec2d(t.x,t.y,e)}throw new Error("Insufficient vector's data")}static getDist(t,e){let s=Vec2d.createFrom(e).sub(Vec2d.createFrom(t));return Math.hypot(s.x,s.y)}static cartToPolar(t){return new Vec2d(Math.cos(t),Math.sin(t))}constructor(t=0,e=0,s=1){this.x=t,this.y=e,this.w=s,this.o={x:0,y:0,w:1},this.angle=Math.atan2(this.y,this.x),this.length=Math.hypot(this.x,this.y)}add(t){let e=Vec2d.createFrom(t);return new Vec2d(this.x+e.x,this.y+e.y)}sub(t){let e=Vec2d.createFrom(t);return new Vec2d(this.x-e.x,this.y-e.y)}scale(t){return new Vec2d(this.x*t,this.y*t)}addScale(t,e){let s=Vec2d.createFrom(t);return new Vec2d(this.x+s.x*e,this.y+s.y*e)}mult(t){let e=Vec2d.createFrom(t);return new Vec2d(this.x*e.x,this.y*e.y)}dot(t){let e=Vec2d.createFrom(t);return this.x*e.x+this.y*e.y}angleBetween(t){let e=Vec2d.createFrom(t);return this.dot(e)/(this.length*e.length)}getDist(t){let e=Vec2d.createFrom(t).sub(this);return Math.hypot(e.x,e.y)}inverse(){return new Vec2d(1/this.x,1/this.y)}normalise(){return 0!==this.length?this.scale(1/this.length):new Vec2d}getOrthogonal(){let t=90*Math.PI/180+this.angle,e=Math.cos(t),s=Math.sin(t);return new Vec2d(e,s)}applyFunc(t){return new Vec2d(t(this.x),t(this.y))}useNMC(t){let e=Vec3d.createFrom(t);return this.x+=1,this.y+=1,this.x*=e.x,this.y*=e.y,new Vec2d(this.x,this.y,1)}clone(){return new Vec2d(this.x,this.y)}toArray(){return[this.x,this.y]}toObject(){return{x:this.x,y:this.y}}draw(t,e,s=0){t.save(),t.lineWidth=s,t.beginPath(),t.moveTo(this.o.x,this.o.y),t.lineTo(this.o.x+this.x,this.o.y+this.y),t.strokeStyle=e,t.stroke(),t.beginPath(),t.arc(this.o.x+this.x,this.o.y+this.y,3+s,0,2*Math.PI),t.closePath(),t.fillStyle=e,t.fill(),t.restore()}}class Vec3d{static createFrom(t){if(t instanceof Vec3d)return t;if(t instanceof Array){let e=void 0===t[3]?1:t[3];return new Vec3d(t[0],t[1],t[2],e)}if(t instanceof Object){let e=void 0===t.w?1:t.w;return new Vec3d(t.x,t.y,t.z,e)}throw new Error("Insufficient vector's data")}static getDist(t,e){let s=Vec3d.createFrom(e).sub(Vec3d.createFrom(t));return Math.hypot(s.x,s.y)}constructor(t=0,e=0,s=0,i=1){this.x=t,this.y=e,this.z=s,this.w=i,this.o={x:0,y:0,z:0,w:1},this.length=Math.hypot(this.x,this.y,this.z)}add(t){let e=Vec3d.createFrom(t);return new Vec3d(this.x+e.x,this.y+e.y,this.z+e.z)}sub(t){let e=Vec3d.createFrom(t);return new Vec3d(this.x-e.x,this.y-e.y,this.z-e.z)}scale(t){return new Vec2d(this.x*t,this.y*t,this.z*t)}addScale(t,e){let s=Vec3d.createFrom(t);return new Vec3d(this.x+s.x*e,this.y+s.y*e,this.z+s.z*e)}mult(t){let e=Vec3d.createFrom(t);return new Vec3d(this.x*e.x,this.y*e.y,this.z*e.z)}dot(t){let e=Vec3d.createFrom(t);return this.x*e.x+this.y*e.y+this.z*e.z}cross(t){let e=Vec3d.createFrom(t),s=this.y*e.z-this.z*e.y,i=this.z*e.x-this.x*e.z,r=this.x*e.y-this.y*e.x;return new Vec3d(s,i,r)}angleBetween(t){let e=Vec3d.createFrom(t);return this.dot(e)/(this.length*e.length)}getDist(t){let e=Vec3d.createFrom(t).sub(this);return Math.hypot(e.x,e.y,e.z)}inverse(){return new Vec3d(1/this.x,1/this.y,1/this.z)}normalise(){return 0!==this.length?this.scale(1/this.length):new Vec3d}applyFunc(t){return new Vec3d(t(this.x),t(this.y),t(this.z))}useNMC(t){let e=Vec3d.createFrom(t);return this.x+=1,this.y+=1,this.x*=e.x,this.y*=e.y,new Vec3d(this.x,this.y,this.z,this.w)}clone(){return new Vec3d(this.x,this.y,this.z)}toArray(){return[this.x,this.y,this.z,this.w]}toObject(){return{x:this.x,y:this.y,z:this.z,w:this.w}}draw(t,e,s,i){let r=Vec3d.createFrom(e);t.save(),t.lineWidth=i,t.beginPath(),t.moveTo(r.x,r.y),t.lineTo(this.x,this.y),t.strokeStyle=s,t.stroke(),t.beginPath(),t.translate(this.x,this.y),t.scale(1,1),t.arc(0,0,3,0,2*Math.PI),t.closePath(),t.fillStyle=s,t.fill(),t.restore()}}class Sprite{constructor(t,e,s=5){this.col=e,this.frames=t,this.currentFrames=[],this.frameName=null;for(const t in this.frames){this.setFrame(t);break}this.delay=s,this.index={x:null,y:null},this._delayCounter=0,this._frameCounter=0,this.state=!1}setFrame(t){if(!this.frames.hasOwnProperty(t))throw new Error("Sprite Frame name does not exists");if(!(this.frames[t]instanceof Array))throw TypeError("Sprite's current frame must be an instance of an Array");this.currentFrames=this.frames[t],this.frameName=t}getSource(){if(this._delayCounter++,this._delayCounter>this.delay){this._delayCounter=0,this._frameCounter++,this._frameCounter>=this.currentFrames.length?(this.state=!1,this._frameCounter=0):this.state=!0;let t=this.currentFrames[this._frameCounter]-1,e=t%this.col,s=t/this.col;this.index={x:e,y:s}}}}const __GLOBAL__={scene:null,fpsTimeStarted:performance.now(),elapsedTimeStarted:performance.now()};class Platformer2D{static getFPS(){let t=performance.now(),e=1e3/(t-__GLOBAL__.fpsTimeStarted);return __GLOBAL__.fpsTimeStarted=t,e}static getElapsedTime(){let t=performance.now(),e=.001*(t-__GLOBAL__.elapsedTimeStarted);return __GLOBAL__.elapsedTimeStarted=t,e>.2&&(e=0),e}static objectToCSSFormat(t){for(let e of t)if(e.charCodeAt()>=65&&e.charCodeAt()<=90){let s=e;t=t.replaceAll(e,`-${s.toLowerCase()}`)}return t}static getTileSetIndex(t,e){return new Vec2d(t%e,t/e)}}class Component{constructor(t,e){this.pos=Vec2d.createFrom(t),this.dimension=Vec2d.createFrom(e),this.velocity=new Vec2d,this.rotation=0,this.vertices=[],this.lastPos=null,this.nextPos=null,this.currentPos=null,this._minpos=null,this._maxpos=null}orthCollision(t,e,{left:s=null,top:i=null}){if(void 0!==t.size&&void 0!==t.dimension){this.lastPos=this.pos,this.nextPos=Vec2d.createFrom({x:player.pos.x+e.x,y:this.lastPos.y}),this._minPos=this.nextPos.mult(Vec2d.createFrom(t.size).inverse()).applyFunc(Math.floor),this._maxPos=this.nextPos.add(this.dimension).mult(Vec2d.createFrom(t.size).inverse()).applyFunc(Math.ceil);for(let e=this._minPos.y;e<this._maxPos.y;e++)for(let i=this._minPos.x;i<this._maxPos.x;i++)this.currentPos=t.map[e*t.dimension.x+i],"function"==typeof s&&s();this.pos=this.nextPos,this.lastPos=this.pos,this.nextPos=Vec2d.createFrom({x:this.lastPos.x,y:this.lastPos.y+e.y}),this._minPos=this.nextPos.mult(Vec2d.createFrom(t.size).inverse()).applyFunc(Math.floor),this._maxPos=this.nextPos.add(this.dimension).mult(Vec2d.createFrom(t.size).inverse()).applyFunc(Math.ceil);for(let e=this._minPos.y;e<this._maxPos.y;e++)for(let s=this._minPos.x;s<this._maxPos.x;s++)this.currentPos=t.map[e*t.dimension.x+s],"function"==typeof i&&i();this.pos=this.nextPos}}}class OrthographicMap{static getMapId(t,e,s=0){let i=Vec2d.createFrom(e);return void 0!==t[0][0]?t[i.y][i.x]:t[i.y*s+i.x]}constructor(t,e){if(!(t instanceof Array))throw TypeError("Failed to Initialize Map: expects an instance of an Array");this.map=t,this.size=Vec2d.createFrom(e),null!=this.map[0][0]?(this.type="2D",this.dimension=Vec2d.createFrom({x:this.map[0].length,y:this.map.length})):(this.type="1D",this.dimension=new Vec2d),this.index=new Vec2d,this.id=null,this.minView=new Vec2d,this.maxView=new Vec2d}setDimension(t){this.dimension=Vec2d.createFrom(t)}setView(t,e){this.minView=Vec2d.createFrom(t),this.maxView=Vec2d.createFrom(e)}render(t){for(let e=this.minView.y;e<this.maxView.y;e++)for(let s=this.minView.x;s<this.maxView.x;s++)this.index=new Vec2d(s,e),this.id=OrthographicMap.getMapId(this.map,this.index,this.dimension.x),t()}}class OrthographicCamera extends Component{constructor(t=new Vec3d,e=new Vec3d){super(t,e),this.minPos=new Vec3d,this.maxPos=new Vec3d}lookAt(t,e){let s=void 0===e?t.size:Vec3d.createFrom(e);this.minPos=this.pos.mult(s.inverse()).applyFunc(Math.floor),this.maxPos=this.pos.add(this.dimension).mult(s.inverse()).applyFunc(Math.ceil)}setMapClamp(t,e){let s=Vec3d.createFrom(t),i=Vec3d.createFrom(e);this.minPos.x<s.x?this.minPos.x=s.x:this.maxPos.x>i.x&&(this.maxPos.x=i.x),this.minPos.y<s.y?this.minPos.y=s.y:this.maxPos.y>i.y&&(this.maxPos.y=i.y)}setPosClamp(t,e){let s=Vec3d.createFrom(t),i=Vec3d.createFrom(e);this.pos.x<s.x?this.pos.x=s.x:this.pos.x+this.dimension.x>i.x&&(this.pos.x=i.x-this.dimension.x),this.pos.y<s.y?this.pos.y=s.y:this.pos.y+this.dimension.y>i.y&&(this.pos.y=i.y-this.dimension.y),this.pos.z<s.z?this.pos.z=s.z:this.pos.z>i.z&&(this.pos.z=i.z)}follow(t,e){let s=Vec3d.createFrom(t),i=Vec3d.createFrom(e);this.pos=s.add(i.scale(.5)).sub(this.dimension.scale(.5))}}
